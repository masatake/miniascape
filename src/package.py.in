#! /usr/bin/python
#
# re-packaging virtualization guest domain from definition file.
#
# Copyright (C) 2009 Satoru SATOH <satoru.satoh at gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
#
# @see http://libvirt.org/formatdomain.html
# @see http://www.qemu.org/qemu-doc.html#SEC19
#

import commands
import libvirt
import logging
import optparse
import os
import re
import shutil
import sys

try:
    import xml.etree.ElementTree as ET  # python >= 2.5
except ImportError:
    import elementtree.ElementTree as ET  # python <= 2.4; needs ElementTree.

try:
    import xattr   # pyxattr
except ImportError:
    # Make up a 'Null-Object' like class mimics xattr module.
    class xattr:
        @classmethod
        def get_all(*args):
            return ()

        @classmethod
        def set(*args):
            return ()



RPMNAME_PREFIX = 'vm'
RPMNAME_SUFFIX = 'image'



class DomainNotFoundError(Exception): pass
class SrcIsDirError(Exception): pass
class DestNotDirError(Exception): pass



def connect():
    #return libvirt.openReadOnly(None)
    return libvirt.openReadOnly('qemu:///system')


def run(cmd_str):
    return commands.getstatusoutput(cmd_str)


def package_name(domain_name, prefix=RPMNAME_PREFIX, suffix=RPMNAME_SUFFIX):
    return '%s-%s-%s' % (prefix, domain_name, suffix)


def is_libvirtd_running():
    """Is the service "libvirtd" running?

    @return  Bool  True (running) or False (not)
    """
    (stat,_out) = run("/etc/rc.d/init.d/libvirtd status  2>&1 > /dev/null")

    return (stat == 0)


def get_domain_xml(domname):
    """Get domain xml content by name.
    """
    if is_libvirtd_running():
        conn = connect()

        try:
            dom = conn.lookupByName(domname)
            return dom.XMLDesc(0)

        except libvirt.libvirtError:
            raise DomainNotFoundError("Not found: '%s'" % domname)
    else:
        return open("/etc/libvirt/qemu/%s.xml" % domname).read()


def parse_domain_xml(xmlstr):
    """Parse domain xml string and returns {arch, [image path], ...}
    """
    tree = ET.fromstring(xmlstr)
    name = tree.findtext('name')
    arch = tree.find('os/type').attrib.get('arch')
    images = [e.attrib.get('file') for e in tree.findall('devices/disk/source')]

    return {'name': name, 'arch': arch, 'images': images}


def base_image_path(image_path):
    """@return  the path of the base image of given image path or "" (given
    image not a delta image)

    example log:

    [root@foo ~]# qemu-img info /var/lib/libvirt/images/rhel-5-cluster-4-disk-1.qcow2
    image: /var/lib/libvirt/images/rhel-5-cluster-4-disk-1.qcow2
    file format: qcow2
    virtual size: 5.0G (5368709120 bytes)
    disk size: 32K
    cluster_size: 4096
    backing file: rhel-5-cluster-4-disk-1-base.qcow2 (actual path: /var/lib/libvirt/images/rhel-5-cluster-4-disk-1-base.qcow2)
    [root@foo ~]#
    """
    ret = ""

    (stat, out) = run("@QEMU_IMG@ info %s" % image_path)
    if stat == 0:
        m = re.match(r'.*backing file: (?P<base>[^ ]+) \(actual path: (?P<base_full>[^ ]+)\)', out, re.DOTALL)
        if m:
            ret = m.groupdict()['base_full']

    return ret


def domain_image_paths(domname):
    images = parse_domain_xml(get_domain_xml(domname))['images']
    base_images = [bp for bp in [base_image_path(p) for p in images] if bp != '']

    return images + base_images


def domain_status(domname):
    """Query the status of the domain by name.

    @return libvirt.VIR_DOMAIN_{RUNNING,SHUTOFF,...}

      * VIR_DOMAIN_RUNNING: running
      * VIR_DOMAIN_SHUTOFF: stopped
      * VIR_DOMAIN_NONE: domain is undefined
      * ...
    """
    if not is_libvirtd_running():
        # VM must not be running if libvirtd is stopped.
        return libvirt.VIR_DOMAIN_SHUTOFF

    conn = connect()
    try:
        ret = conn.lookupByName(domname).info()[0]  # should be one.
    except libvirt.libvirtError:
        logging.debug("The domain '%s' is not defined." % domname)
        ret = libvirt.VIR_DOMAIN_NONE
        
    return ret


def createdir(dir, mode=0700):
    if os.path.exists(dir):
        logging.warn("The dir already exists: '%s'" % dir)
        if not os.path.isdir(dir):
            raise IOError("Not a directory: '%s'" % dir)
    else:
        logging.info("Creating a dir: '%s' (mode: %o)" % (dir, mode))
        os.makedirs(dir, mode)


def copyfile(src, dst, force=False):
    """
    @param  src  source path
    @param  dst  destination to copy to. dst may be a dir.
    """
    assert src != dst, "src == dst!"

    if not os.path.isdir(dst):
        if not force and os.path.exists(dst):
            logging.warn(" Copying destination '%s' already exists! Skipt it." % dst)
            return

    # copy itself and its some metadata (owner, mode, etc.)
    logging.info(" Copying '%s' -> '%s'..." % (src,dst))
    shutil.copy2(src, dst)

    # These are not copyed with the above.
    _xattrs = dict(xattr.get_all(src))
    if _xattrs:
        logging.info(" Copying xattrs...")
        for k,v in _xattrs.iteritems():
            xattr.set(dst, k, v)

    logging.info(" Done.")


def substfile(src, dst, substs={}):
    assert src != dst, "src == dst!"

    content = open(src).read()
    for org, new in substs.iteritems():
        content = content.replace(org, new)

    f = open(dst, 'w')
    f.write(content)
    f.close()


def buildfile_path(buildfile, prefix):
    return os.path.join(prefix, buildfile)


# actions:
def do_setup(domain_name, buildfile_dir, *args):
    """setup packaging dir.
    """
    builddir = package_name(domain_name)

    # TODO: later
    #xml = get_domain_xml(domain_name)
    #dominfo = parse_domain_xml(xml)
    #domain_arch = dominfo['arch']

    domxml = get_domain_xml(domain_name)
    domain_images = domain_image_paths(domain_name)

    substs = {
        '@@DOMAIN_NAME@@': domain_name,
        '@@DOMAIN_IMAGES@@': ' '.join((os.path.basename(p) for p in domain_images))
    }

    createdir(builddir)

    open("%s/%s.xml" % (builddir, domain_name), 'w').write(domxml)

    copyfile(buildfile_path('README.in', buildfile_dir), builddir)
    copyfile(buildfile_path('rpm.mk', buildfile_dir), builddir)
    copyfile(buildfile_path('vm-image.spec.in', buildfile_dir), builddir)
    copyfile(buildfile_path('Makefile.am.in', buildfile_dir), os.path.join(builddir, 'Makefile.am'))

    substfile(buildfile_path('configure.ac.in', buildfile_dir), os.path.join(builddir, 'configure.ac'), substs)

    for image in domain_images:
        copyfile(image, builddir)


def do_build(domain_name, *args):
    """Build RPM of $domain_name
    """
    builddir = package_name(domain_name)

    if not os.path.isdir(builddir):
        do_setup(domain_name)

    os.system("cd %s && autoreconf -vfi && ./configure && make" % builddir)
    os.system("cd %s && make srpm && make rpm" % builddir)


def option_parser():
    parser = optparse.OptionParser("%prog [OPTION ...] COMMAND DOMAIN_NAME\n\n"
        "Commands: setup, build\n")
    parser.add_option('-p', '--path', default='@REPACKAGEFILE_DIR@', help='path to build data [%default]')
    parser.add_option('-v', '--verbose', dest='verbose', action="store_true",
        default=False, help='verbose mode')
    parser.add_option('-q', '--quiet', dest='quiet', action="store_true",
        default=False, help='quiet mode')

    return parser


def main():
    action = do_setup
    loglevel = logging.INFO

    parser = option_parser()
    (options, args) = parser.parse_args()

    if options.verbose:
        loglevel = logging.DEBUG
    if options.quiet:
        loglevel = logging.WARN

    # logging.basicConfig() in python older than 2.4 cannot handle kwargs,
    # then exception 'TypeError' will be thrown.
    try:
        logging.basicConfig(level=loglevel)

    except TypeError:
        # To keep backward compatibility. See above comment also.
        logging.getLogger().setLevel(loglevel)

    if len(args) < 2:
        parser.print_help()
        sys.exit(1)

    if args[0].startswith('setu'):
        action = do_setup
    elif args[0].startswith('bui'):
        action = do_build
    else:
        parser.print_usage()

    domain_name = args[1]
    buildfile_dir = options.path

    stat = domain_status(domain_name)
    if stat != libvirt.VIR_DOMAIN_SHUTOFF:
        if stat == libvirt.VIR_DOMAIN_RUNNING:
            logging.error(" VM '%s' is still running. Please shutdown it first." % domain_name)
        else:
            logging.error(" VM '%s' is unknown." % domain_name)

        sys.exit(1)
            
    action(domain_name, buildfile_dir)


if __name__ == '__main__':
    main()

# vim:sw=4:ts=4:et:ft=python:
