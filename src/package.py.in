#! /usr/bin/python
#
# * repackage virtualization guest domain from definition file
# * build and package virtualization guest domain
#
# Copyright (C) 2009 Satoru SATOH <satoru.satoh at gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
#
# @see http://libvirt.org/formatdomain.html
# @see http://www.qemu.org/qemu-doc.html#SEC19
#

import commands
import libvirt
import logging
import optparse
import os
import re
import shutil
import sys

from os.path import join as pathjoin

try:
    import xml.etree.ElementTree as ET  # python >= 2.5
except ImportError:
    import elementtree.ElementTree as ET  # python <= 2.4; needs ElementTree.

try:
    import xattr   # pyxattr
except ImportError:
    # Make up a 'Null-Object' like class mimics xattr module.
    logging.warn("pyxattr does not look installed. Fallback to Dummy implementation")
    class xattr:
        @classmethod
        def get_all(*args):
            return ()

        @classmethod
        def set(*args):
            return ()



PACKAGE_DATA_DIR = '@PACKAGE_DATA_DIR@'
DOMAIN_VARIANT = 'minimal'

RPMNAME_PREFIX = 'vm'
RPMNAME_SUFFIX = DOMAIN_VARIANT

AUXDIR = 'aux'
M4DIR = pathjoin(AUXDIR, 'm4')


class DomainNotFoundError(Exception): pass
class SrcIsDirError(Exception): pass
class DestNotDirError(Exception): pass



def connect():
    #return libvirt.openReadOnly(None)
    return libvirt.openReadOnly('qemu:///system')


def run(cmd_str):
    return commands.getstatusoutput(cmd_str)


def package_name(domain_name, prefix=RPMNAME_PREFIX, suffix=RPMNAME_SUFFIX):
    return '%s-%s-%s' % (prefix, domain_name, suffix)


def is_libvirtd_running():
    """Is the service "libvirtd" running?

    @return  Bool  True (running) or False (not)
    """
    (stat,_out) = run("/etc/rc.d/init.d/libvirtd status  2>&1 > /dev/null")

    return (stat == 0)


def get_domain_xml(domname):
    """Get domain xml content by name.
    """
    if is_libvirtd_running():
        conn = connect()

        try:
            dom = conn.lookupByName(domname)
            return dom.XMLDesc(0)

        except libvirt.libvirtError:
            raise DomainNotFoundError("Not found: '%s'" % domname)
    else:
        return open("/etc/libvirt/qemu/%s.xml" % domname).read()


def parse_domain_xml(xmlstr):
    """Parse domain xml string and returns {arch, [image path], ...}
    """
    tree = ET.fromstring(xmlstr)
    name = tree.findtext('name')
    arch = tree.find('os/type').attrib.get('arch')
    images = [e.attrib.get('file') for e in tree.findall('devices/disk/source')]

    return {'name': name, 'arch': arch, 'images': images}


def domainname_from_xml(xml):
    """Parse domain xml file and returns domain name.
    """
    xml_content = open(xml).read()
    name = parse_domain_xml(xml_content).get('name')

    return name


def base_image_path(image_path):
    """@return  the path of the base image of given image path or "" (given
    image not a delta image).

    example log:

    [root@foo ~]# qemu-img info /var/lib/libvirt/images/rhel-5-cluster-4-disk-1.qcow2
    image: /var/lib/libvirt/images/rhel-5-cluster-4-disk-1.qcow2
    file format: qcow2
    virtual size: 5.0G (5368709120 bytes)
    disk size: 32K
    cluster_size: 4096
    backing file: rhel-5-cluster-4-disk-1-base.qcow2 (actual path: /var/lib/libvirt/images/rhel-5-cluster-4-disk-1-base.qcow2)
    [root@foo ~]#
    """
    ret = ""

    (stat, out) = run("@QEMU_IMG@ info %s" % image_path)
    if stat == 0:
        m = re.match(r'.*backing file: (?P<base>[^ ]+) \(actual path: (?P<base_full>[^ ]+)\)', out, re.DOTALL)
        if m:
            ret = m.groupdict()['base_full']

    return ret


def domain_image_paths(domain_xml_content):
    images = parse_domain_xml(domain_xml_content)['images']
    base_images = [bp for bp in [base_image_path(p) for p in images] if bp != '']

    return images + base_images


def domain_status(domname):
    """Query the status of the domain by name.

    @return libvirt.VIR_DOMAIN_{RUNNING,SHUTOFF,...}

      * VIR_DOMAIN_RUNNING: running
      * VIR_DOMAIN_SHUTOFF: stopped
      * VIR_DOMAIN_NONE: domain is undefined
      * ...
    """
    if not is_libvirtd_running():
        # VM must not be running if libvirtd is stopped.
        return libvirt.VIR_DOMAIN_SHUTOFF

    conn = connect()
    try:
        ret = conn.lookupByName(domname).info()[0]  # should be one.
    except libvirt.libvirtError:
        logging.debug("The domain '%s' is not defined." % domname)
        ret = libvirt.VIR_DOMAIN_NONE
        
    return ret


def createdir(dir, mode=0700):
    if os.path.exists(dir):
        logging.warn("The dir already exists: '%s'" % dir)
        if not os.path.isdir(dir):
            raise IOError("Not a directory: '%s'" % dir)
    else:
        logging.info("Creating a dir: '%s' (mode: %o)" % (dir, mode))
        os.makedirs(dir, mode)


def copyfile(src, dst, force=False):
    """
    @param  src  source path
    @param  dst  destination to copy to. dst may be a dir.
    """
    assert src != dst, "src == dst!"

    if not os.path.isdir(dst):
        if not force and os.path.exists(dst):
            logging.warn(" Copying destination '%s' already exists! Skipt it." % dst)
            return

    # copy itself and its some metadata (owner, mode, etc.)
    logging.info(" Copying '%s' -> '%s'..." % (src,dst))
    shutil.copy2(src, dst)

    # These are not copyed with the above.
    _xattrs = dict(xattr.get_all(src))
    if _xattrs:
        logging.info(" Copying xattrs...")
        for k,v in _xattrs.iteritems():
            xattr.set(dst, k, v)

    logging.info(" Done.")


def substfile(src, dst, substs={}):
    assert src != dst, "src == dst!"

    content = open(src).read()
    for org, new in substs.iteritems():
        content = content.replace(org, new)

    f = open(dst, 'w')
    f.write(content)
    f.close()


def make_builddir(workdir, domain_name):
    return pathjoin(workdir, package_name(domain_name))


# actions:
def do_repackage_setup(libpath, domain_name, domain_variant, domain_xml, builddir, *args):
    """setup packaging dir and files to re-package vm images.
    """
    if domain_xml:
        domxml_content = open(domain_xml).read()
    else:
        domxml_content = get_domain_xml(domain_name)

    domain_images = domain_image_paths(domxml_content)

    substs = {
        '%%DOMAIN_NAME%%': domain_name,
        '%%DOMAIN_VARIANT%%': domain_variant,
        '%%DOMAIN_IMAGES%%': ' '.join((os.path.basename(p) for p in domain_images))
    }

    createdir(builddir)
    createdir(pathjoin(builddir, M4DIR))

    open("%s/%s.xml" % (builddir, domain_name), 'w').write(domxml_content)

    copyfile(pathjoin(libpath, AUXDIR, 'rpm.mk'), pathjoin(builddir, AUXDIR))
    copyfile(pathjoin(libpath, M4DIR, 'qemu.m4'), pathjoin(builddir, M4DIR))
    copyfile(pathjoin(libpath, M4DIR, 'rpm.m4'), pathjoin(builddir, M4DIR))
    copyfile(pathjoin(libpath, 'repackage', 'Makefile.am.in'), pathjoin(builddir, 'Makefile.am'))
    copyfile(pathjoin(libpath, 'repackage', 'README.in'), builddir)
    copyfile(pathjoin(libpath, 'repackage', 'vm-image.spec.in'), \
        pathjoin(builddir, 'vm-%s-%s.spec.in' % (domain_name, domain_variant)))

    substfile(pathjoin(libpath, 'repackage', 'configure.ac.in'), pathjoin(builddir, 'configure.ac'), substs)

    for image in domain_images:
        copyfile(image, builddir)


def do_package_setup(libpath, domain_name, domain_variant, builddir, *args):
    """setup packaging dir and files to package vm images.
    """
    substs = {
        '%%DOMAIN_NAME%%': domain_name,
        '%%DOMAIN_VARIANT%%': domain_variant,
    }

    createdir(builddir)
    createdir(pathjoin(builddir, 'data'))
    createdir(pathjoin(builddir, M4DIR))

    # configure.ac.in  data  vm-image.spec.in
    copyfile(pathjoin(libpath, AUXDIR, 'rpm.mk'), pathjoin(builddir, AUXDIR))
    copyfile(pathjoin(libpath, M4DIR, 'libvirt.m4'), pathjoin(builddir, M4DIR))
    copyfile(pathjoin(libpath, M4DIR, 'qemu.m4'), pathjoin(builddir, M4DIR))
    copyfile(pathjoin(libpath, M4DIR, 'rpm.m4'), pathjoin(builddir, M4DIR))
    copyfile(pathjoin(libpath, M4DIR, 'virtinst.m4'), pathjoin(builddir, M4DIR))
    copyfile(pathjoin(libpath, 'package', 'Makefile.am.in'), pathjoin(builddir, 'Makefile.am'))
    copyfile(pathjoin(libpath, 'package', 'README.in'), builddir)
    copyfile(pathjoin(libpath, 'package', 'vm-image.spec.in'), \
        pathjoin(builddir, 'vm-%s-%s.spec.in' % (domain_name, domain_variant)))
    copyfile(pathjoin(libpath, 'package', 'data', 'Makefile.am.in'), pathjoin(builddir, 'data', 'Makefile.am'))

    substfile(pathjoin(libpath, 'package', 'configure.ac.in'), pathjoin(builddir, 'configure.ac'), substs)


def do_build(domain_name, builddir):
    """Build domain $domain_name.
    """
    if not os.path.isdir(builddir):
        raise RuntimeError("build dir is not ready! 'setup' it first.")

    (stat, out) = run("cd %s && autoreconf -vfi && ./configure && make" % builddir)
    if stat != 0:
        raise RuntimeError("Build stopped during 'make': '%s'" % out)

    return stat


def do_dist(domain_name, builddir):
    """Build dist.
    """
    if not os.path.isdir(builddir):
        raise RuntimeError("build dir is not ready! 'setup' it first.")

    (stat, out) = run("cd %s && (test -f configure || autoreconf -vfi) && ./configure && make dist-@SOURCE_ZIP@" % builddir)
    if stat != 0:
        raise RuntimeError("Build stopped during 'make dist': '%s'" % out)

    return stat


def do_package(domain_name, builddir):
    """Build [s]rpm of $domain_name
    """
    if not os.path.isdir(builddir):
        raise RuntimeError("build dir is not ready! 'setup' and 'build' it first.")

    (stat, out) = run("cd %s && make srpm && make rpm" % builddir)
    if stat != 0:
        raise RuntimeError("Build stopped during 'make [s]rpm': '%s'" % out)

    return stat


def option_parser():
    parser = optparse.OptionParser("""%prog COMMAND [OPTION ...] [ARGS ...]
Commands: pack[age] and repack[age]

Examples:
    %prog pack dom-1 
    %prog repack dom-1.xml 
"""
    )
    parser.add_option('-L', '--libpath', default=PACKAGE_DATA_DIR,
        help='Path to search library files [%default]')
    parser.add_option('', '--workdir', default=os.curdir, help='Working directory [%default]')
    parser.add_option('', '--variant', default=DOMAIN_VARIANT, help='Domain variant [%default]')
    parser.add_option('-v', '--verbose', dest='verbose', action="store_true",
        default=False, help='verbose mode')
    parser.add_option('-q', '--quiet', dest='quiet', action="store_true",
        default=False, help='quiet mode')

    sog = optparse.OptionGroup(parser, "Staging options")
    sog.add_option('', '--build', action="store_true", default=False,
        help='Setup and build (domain installation). Not effective for "repackage" command.')
    sog.add_option('', '--package', action="store_true", default=False, help='Setup, build and package')
    parser.add_option_group(sog)

    #rog = optparse.OptionGroup(parser, "Options for 'repackage'")
    #rog.add_option('', '--xml', default=False, help='Domain XML in full path.')
    #parser.add_option_group(rog)

    return parser


def main(argv=sys.argv):
    loglevel = logging.INFO

    parser = option_parser()

    if len(argv) < 2:
        parser.print_usage()
        sys.exit(1)

    cmd = argv[1]

    if cmd.startswith('pack'):
        cmd = 'package'
    elif cmd.startswith('repack'):
        cmd = 'repackage'

    (options, args) = parser.parse_args(argv[2:])

    if options.verbose:
        loglevel = logging.DEBUG
    if options.quiet:
        loglevel = logging.WARN

    # logging.basicConfig() in python older than 2.4 cannot handle kwargs,
    # then exception 'TypeError' will be thrown.
    try:
        logging.basicConfig(level=loglevel)

    except TypeError:
        # To keep backward compatibility. See above comment also.
        logging.getLogger().setLevel(loglevel)

    if cmd == 'package':
        if len(args) < 1:
            print >> sys.stderr, "%s pack[age] DOMAIN_NAME [OPTIONS...]" % sys.argv[0]
            sys.exit(1)

        domain_name = args[0]
        builddir = make_builddir(options.workdir, domain_name)

        do_package_setup(options.libpath, domain_name, options.variant, builddir)

    elif cmd == 'repackage':
        if len(args) < 1:
            print >> sys.stderr, "%s repack[age] DOMAIN_XML [OPTIONS...]" % sys.argv[0]
            sys.exit(1)

        domain_xml = args[0]
        domain_name = domainname_from_xml(domain_xml)
        builddir = make_builddir(options.workdir, domain_name)

        stat = domain_status(domain_name)
        if stat != libvirt.VIR_DOMAIN_SHUTOFF:
            if stat == libvirt.VIR_DOMAIN_RUNNING:
                logging.error(" VM '%s' is still running. Please shutdown it first." % domain_name)
            else:
                logging.error(" VM '%s' is unknown state." % domain_name)

            sys.exit(1)

        do_repackage_setup(options.libpath, domain_name, options.variant, domain_xml, builddir)
    else:
        parser.print_usage()
        sys.exit(1)

    ret = 0
    if options.build or options.package:
        ret = do_build(domain_name, builddir)
        if ret != 0:
            raise RuntimeError("build failed.")

    ret = do_build(domain_name, builddir)
    if ret != 0:
        raise RuntimeError("'make dist' failed.")

    if options.package:
        ret = do_package(domain_name, builddir)

    sys.exit(ret)


if __name__ == '__main__':
    main()

# vim:sw=4:ts=4:et:ft=python:
